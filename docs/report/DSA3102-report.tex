\documentclass{article}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{float}
\usepackage{pdfpages}
\usepackage{tcolorbox}

\definecolor{light-gray}{gray}{0.9}
\lstset{frame=tb,
extendedchars = true,
texcl=true,
  language=bash,
  aboveskip=3mm,
  belowskip=3mm,
  frame=none,
  backgroundcolor=\color{light-gray},
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{mauve},
  breaklines=true,
  tabsize=3
}

\graphicspath{ {./img/} }

\author{Kent Odde, Stian Onarheim, Tarald Vestbøstad}
\title{Title}

\begin{document}

\pagestyle{empty}

 \begin{tikzpicture}[remember picture,overlay]
    \node[anchor=north west,yshift=-15pt,xshift=20pt]%
        at (current page.north west)
        {\includegraphics[height=8em]{img/USN_logotype.png}};

\end{tikzpicture}


%\vspace{2.5cm}

{\LARGE test}\hspace{2cm}

\begin{tikzpicture}[overlay]
    \node[anchor=north, inner sep=0] at (4,-2)
        {\includegraphics[width=\textwidth]{img/frontpage-block.png}};
\end{tikzpicture}

\begin{tikzpicture}[overlay]
    \node[anchor=north, inner sep=0] at (-3,-0) {\large Hello};
        
\end{tikzpicture}

\maketitle

\newpage
\tableofcontents


\newpage
\section{Abstract}
This is our submission for the semester assignemnt in the course Real-Time Systems DSA3102, fall of 2020.


\section{Introduction}
The semester assignment as given, was to design and implement a real-time system, which would run on an Arduino Nano 33 BLE Sense, with the requirement that it would be programmed in Ada. 


A broad definition of a real-time system, is a system that reacts to external stimuli, make calucations, and performs some output, within a given deadline. In other words, the challenge here is not only to write a logically correct program, but also that it finishes all tasks in time. Which naturally increases the difficulty. 


This report will explain our project choice as well as the design. It will give a detailed description of the challenges, especially concerning running Ada on an Arduino Nano. Finally we will explain how the final solution works, and how we can prove that it is safe, and that the system will be able to meet all its deadlines. 


\section{Specifications}

Very early on, we decided on building an autonomous car. We initially had a plan on using a hololens to interact with the car in some way, but we quickly moved away from this, in order to reduce the overall complexity. 

The car should not only drive, but it would also have a bottle of antibac on top of it, with a sensor that would stop the car, and provide a person with a few drops of desinfecting liquid. 

The initial design looked like this. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{prototype-drawing.png}
	\caption{Prototype drawing of our vehicle}
	\label{ProtoDrawing}
\end{figure}

As the car would provide people with antibac, we naturally wanted the car to be able to drive on top of a table. That is why it had downpointing sensors, to be able to know when it would drive of an edge. However, after receiving the car from our professor, we quickly found, that the navigation system we would need to implement would be way to comprehensive, given the small timefram of the assignment. 

Throughout the project, the system went through several iterations, as as we met challenges along the way, the antibac idea was abandoned. The final design would look like this:

*********Diagram eller bilde av sluttdesign********************

\section{Technologies}

\subsection{The Ada Programming Language}

\subsection{Arduino Nano 33 BLE Sense}





\section{Implementation}
\subsection{Ada on the Arduino}

\subsubsection{Ada Drivers Library}

\subsubsection{Ravenscar Run-time Library}


\newpage
\section{Maybe useful text}

Thursday 20. August 2020, the group gathered and had a meeting with Steven Bos. We discussed our project idea and the potential use of the Microsoft HoloLens 2. It was in the group's best interest to put our resources into the microcontroller rather than the goggles, dismissing any development with the HoloLens.

\vspace{5mm}
On September 10. the group met to plan the project. After deciding on the initial design, we drew a sketch and wrote a short description. This was sent to our professor, along with a list of required parts as well as the associated budget. The initial design can be seen in section XX.

\vspace{5mm}

On the 16th of September, we ordered three Arduino Nano 33 BLE Sense w/headers from Arduino.cc. This came to 1080NOK. In addition to this the professor provided us with a car for the project. It is called Turnigy Trooper \cite{CAR}, and was originally a radio controlled car. However everything but the battery and servo motors for thrust and steering, have been stripped away. 

The servo motors are controlled by a pulse-width modulated signal. This means in essence that we send discrete signals, where the signal will rise at a fixed frequency. The length of time the signal is high before going low will determine the behaviour of the servo motors. Luckily for us there is a standard regarding the behaviour generated by a specific pulse width. 

We will need to write a library which will abstract this away in the code. Where the interface for steering will take an angle, and the motor interface will hopefully be able to take a velocity in m/s, where negative numbers will mean going backwards.

\vspace{5mm}
%Litt vanskelig med fortid og nåtid i formuleringa her = p
After Steven showed us a proof of concept that it will be quite doable to base our library for the Arduino Nano on the existing toolchain for NRF52840, we started developing on the 17th of September. However there quickly emerged a problem, as Gnat arm-elf initally only supports ZFP-runtime libraries for this card. This meant that it would only support barebone functionality, and we would never be able to make use of the Ada realtime library, or even multithreading the software. Luckily, there exists support for full ravenscar run-time libraries for the card. We followed the official guide at the bb-runtime repo \cite{BBRUNTIMES}, to generate and build them ourselves.

%Before we could start using Ada's real-time library under runtime, we had to generate the library for our microcontroller nRF52840. We followed the official guide [kilde]\url{https://github.com/AdaCore/bb-runtimes} to generate and build the library. 

\begin{lstlisting}
./build_rts.py --rts-src-descriptor ~/opt/GNAT/2020-arm-elf/arm-eabi/lib/gnat/rts-sources.json --output=temp nrf52840
\end{lstlisting}

\begin{lstlisting}
gprbuild -P ~/opt/GNAT/2020-arm-elf/lib/gnat/arm-eabi/lib/gnat/ravenscar-full-nrf52840/ravenscar-build.gpr
\end{lstlisting}


\vspace{5mm}
On the 18th of September we improved our library build, by letting the project\_wizard script in Ada drivers library generate the gpr-files for our board automatically. All we had to do was to provide some basic information about the microcontroller, and the script did the rest. We also started adapting the pin mappings from the nRF52832 to the nRF52840. 

Provided that our efforts lead to a useful library, we will create a pull request into the Ada drivers library, so that others may benefit from our work. 

\begin{lstlisting}
./Ada_Drivers_Library/scripts/project_wizard.py
\end{lstlisting}

\vspace{5mm}

October 5. 

We received the Segger J-Link debugger from our professor. In order to get this to work, we installed the firmware from segger.com. However we also had to install a pack for pyocd in order to find the debugger:


\begin{lstlisting}
pyocd pack --install  stm32l476VG
\end{lstlisting}

As all development within the group is done on Linux, we also had to add udev rules, so that we were able to access the usb ports without being root. These rule-sets were found on pyocds git repository.

We also had to give the respective user access to the serial port by running the command: 
\begin{lstlisting}
usermod -a -G dialout MY\_USER\_NAME
\end{lstlisting}

Legge til utilization test og grafikk.
\vspace{5mm}

October 12. 

We are able to flash and debug by manually holding cables to the debug connections on the Arduino. We used the diagram on the segger website \cite{JLINK} to find out which JLink pins to "connect" to the Arduino points.

AnalogWrite seems like the perfect choice to generate a pulse for both servo and sensor. In the Ada Drivers Library \cite{ADADRIVERSLIBRARY} there is a very good example for controlling a servo. It changes the analog signal period with \textbf{Set\_Analog\_Period\_Us} to generate a steady pulse.

However we were never able to make it work on the arduino. Seems to be a problem with incompatibility between the drivers and the Arduino or the nRF52840 chip.\\
We suspect it is tied to interrupts since the stacktrace from the debugger kept stopping on a new line each time.

Progress is slow because of the manual labour required for each flash and debugging session.
\vspace{5mm}

October 19. 

We recieved the clamps from Richard and Steven was able to put it together with the Arduino and a breadboard. We are finally able to easily flash and debug.

We were able to create a steady pulse using digital I/O and tasks with a fixed priority. With a proper priority we were able to use three tasks for three separate servos and one task for three sensors.

We encountered some problems using a 9V battery power source, as the Ardino requires at least 5V and the peripherals need 5V.


\vspace{5mm}
October 21.

We wrote the code for the entire system.


\vspace{5mm}
October 22.

This was the first day we tested our servo code on the car. After a lot of trial and error on the steering we quickly moved on to the drive motor. We got the wheels to move fairly quickly after discovering that the motor needs a neutral (1500ms PWM) signal to intialize, before giving it signals which indicate torque. However, there quickly emerged problems. First of all the minimum speed was much to high, and secondly, it was impossible to get the car to switch between going forwards and backwards. After conversations with our professor, we learned that Joakim Bjork, had worked a lot with this car, and sat on a lot of documentation for the motors. This documentation would be made available for us on the next day.

\vspace{5mm}

Obtober 23.

\textbf{D-Day} (Documentation day)

\section{Ravenscar}

The full ravenscar run-time library offers what is called the Ravenscar profile. This is a subset of the Ada language, where the features and available libraries are limited. The reason for this is to ensure robust software on realtime and safety critical systems. 

The specifications of the ravenscar profile are the following:
%Lim inn liste kanskje?
https://www.ada-switzerland.ch/rm/RM-D-13.html

There are a couple of limitations here that will affect the way we initially planned our software. 

The maximum number of entries in tasks are set to 0. This means that we won't be able do have dynamic tasking, and all tasks will rather have to be defined at compile-time. 

Another thing we planned was to specify which tasks would run on the respective cores of the CPU. This however, is not supported within the ravenscar profile, and we will need to do all the scheduling as if we only had a single-core processor. 

\section{Various problems we've encountered along the way}

By the time you're reading this, some of these issues might have been fixed. Down below are some problems we have encountered during our development phase from 17.02.2020 - ??. Most of these issues have occured using Linux, it is stated otherwise.


\begin{itemize}
	\item Flashing to the Arduino board without a debugging probe might be impossible.

	\item After installing software for the Segger J-Link debugger from their official webpage, a new .rules file for the debugger appears in $/etc/udev/rules.d$ containing the necessary information for the debugger to be found by $pyocd\ list$. This has only been successful with one of our computers. A workaround is to run pyocd with sudo privileges.

	\item Including unused libraries in the Ada source-code makes the arduino crash under run-time.

	\item When trying to flash to the board without having the cables soldered, errors in the list below have appeared as a consequence of unstable hands.
		\begin{itemize}
			\item Unable to start CPU core.
			\item Target System has no power.
            \item Unspecified Error.
            \item J-Link is already open.
		\end{itemize}

	\item Including Arduino\_Nano\_33\_Ble\_Sense.Time makes the microcontroller crash in real time. --ref til Debug lstlisting i appendix--

	\item Only Digital I/O works. Possibly because Analog relies on interrupt/timers which seem broken in our drivers or runtime.

	\item Generating a pulse accepted by the servos and ultrasonic sensor is more challenging than setting pins to low/high and using a delay.

	\item Using a copied bb-runtime library will not work correctly on other computers under debugging. They must be generated on every new computer.

\end{itemize}

\subsection{Pin layout}
11.10.2020\\
The nRF52840 has two ports, P0 has 32 pins while P1 has 16 pins.\\ 
We found the P1 base address for the nRF52840 seen on page 23 in the datasheet \cite{NRF52840}. Without it we were only able to use the pins with P0 seen on figure \ref{pinlayout}. After adding the base address to the Ada code and the option to chose between 0 and 47 pin number we were able to make all the pins function.


\newpage
\section{Maybe useful pictures}


\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{system-architecture.png}
	\caption{Block diagram of our system architecture}
	\label{SystemArchBlock}
\end{figure}



\section{Conclusion}

The purpose of this assigment was to try and implement the theory relating to real-time systems in practice, in order to better understand it. In spite of the challenges along the way, and how we had to downscale the project several times, we would still say that this goal was accomplished.

One can read about the difficulty of making a system meet all its deadlines, how scheduling works and what happens when a thread is starving, nothing can beat the feeling of actually experiencing it. As mentioned, we had several tasks that did'nt deliver the output we expected, and many times this was due to the task not getting any time on the CPU. That is a powerful experience. 

Learning to program in Ada along the way, as well as building the the ravenscar run-time library and the library for the NRF52840, was great, is guaranteed to prove very useful knowledge in the future. 


\newpage
%Referanse
\nocite{*}
\bibliographystyle{plain}
\bibliography{ref}
\addcontentsline{toc}{section}{References}

\newpage
\section{Maybe appendix}

\subsection{Stacktrace}
\lstset{frame=tb,
extendedchars = true,
texcl=true,
  language=Ada,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{black},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\includepdf[scale=1.0,pages=-,pagecommand=\subsection{Arduino Nano 33 BLE sense PIN layout\label{pinlayout}}]{pdf/Pinout-NANOsense_latest.pdf}

\end{document}

